@model List<RoleViewModel> // List<AppRole>

@{
    ViewData["Title"] = "Roles";
    Layout = "~/Areas/Admin/Views/Admin/_AdminLayout.cshtml";
}

<style>

    .position {
        width: 25%;
        position: relative;
    }

    .position p {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    .btnposition{
    vertical-align: middle;
    text-align: center;
    }

</style>


<h3>Roller</h3>
<hr />

 <div class="col-md-8 offset-md-2">
<table class="table table-hover table-bordered table-striped">
    <tr>
        @*<th>Id</th>*@
        <th class="position"><p>Rol ismi</p></th>
        <th class="position"><p>Silme</p></th>
        <th class="position"><p>Güncelleme</p></th>
    </tr>

    @foreach (var item in Model)
    {
        <tr>

           @* <td>@item.Id</td>*@
                <td class="position"><p>@item.Name</p></td>
                <td class="btnposition"><a class="btn btn-warning" asp-action="RoleUpdate" asp-route-id="@item.Id">Güncelle</a></td>
                <td class="btnposition">
                    <form asp-action="RoleDelete" asp-route-id="@item.Id" method="post">
                    @*Delete işleminde direkt post metodu çalışacağından form(submit) içine alındı, update de ise önce get metod çalışacak o yüzden update klasik şekilde yazıldı.... a tag helper bu işlemi yapamazdı o yüzden form/button kullanıldı. Çünkü a taghelper get metodunu çalıştırabilir.. post metodu değil.... burada da olduğu gibi mvc ve mvc core'da birden fazla form tanımlanabilir..

                    form action içerisinde asp-route-id="@item.Id" YERİNE input hidden denedim olmadı!!!

                    <input type="hidden" asp-for="@item.Id" /> OLMADI!!!

                    *@
 
                    <button class="btn btn-danger" type="submit">Sil</button>
                </form>
            </td>
            
        </tr>

    }
</table>
<a asp-action="RoleCreate" class="btn btn-info">Role Oluştur</a>
</div>
